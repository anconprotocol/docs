"use strict";(self.webpackChunkancon_docs=self.webpackChunkancon_docs||[]).push([[615],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(t),m=o,f=u["".concat(c,".").concat(m)]||u[m]||p[m]||a;return t?r.createElement(f,i(i({ref:n},d),{},{components:t})):r.createElement(f,i({ref:n},d))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2801:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var r=t(7462),o=t(3366),a=(t(7294),t(3905)),i=["components"],s={sidebar_position:2},c="Using a Verifiable DAG store",l={unversionedId:"api/metadata",id:"api/metadata",isDocsHomePage:!1,title:"Using a Verifiable DAG store",description:"Ancon Protocol Node is an Layer 2, offchain DAG Store with verifiable data. Anyone can use it once they registered a DID with the L2, which will generate a vector commitment proof, if indeed the register exists or not in the merkle tree.",source:"@site/docs/api/metadata.md",sourceDirName:"api",slug:"/api/metadata",permalink:"/docs/api/metadata",editUrl:"https://github.com/anconprotocol/ancon-docs/docs/api/metadata.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"API Reference",permalink:"/docs/api/reference"},next:{title:"Trusted offchain gateways",permalink:"/docs/api/durin"}},d=[{value:"Staking and Validators",id:"staking-and-validators",children:[],level:2},{value:"Onchain metadata",id:"onchain-metadata",children:[{value:"Smart contracts",id:"smart-contracts",children:[],level:3},{value:"Client",id:"client",children:[],level:3}],level:2},{value:"AnconProtocol.sol",id:"anconprotocolsol",children:[],level:2},{value:"Metadata JSON Schema",id:"metadata-json-schema",children:[{value:"Example",id:"example",children:[],level:3}],level:2}],p={toc:d};function u(e){var n=e.components,t=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"using-a-verifiable-dag-store"},"Using a Verifiable DAG store"),(0,a.kt)("p",null,"Ancon Protocol Node is an Layer 2, offchain DAG Store with verifiable data. Anyone can use it once they registered a DID with the L2, which will generate a vector commitment proof, if indeed the register exists or not in the merkle tree."),(0,a.kt)("p",null,"Because there is no consensus involved, we can only be sure that it was signed by someone using a DID identifier. To be able to have a more decentralized feature, is recommended to anchor both DID and proofs in a ICS23 Vector Commitment compatible smart contract chain."),(0,a.kt)("p",null,"Once is submitted to a onchain solution, any offchain operation can be properly validated onchain for any proofs."),(0,a.kt)("h2",{id:"staking-and-validators"},"Staking and Validators"),(0,a.kt)("p",null,"Ancon Protocol will implement a smart contract based validator approach, where the incentives will be to batch proofs operations, validate them, and then submit or commit to protocol header updates. Using $ANCON token, validators will be able to stake and obtain a income by supporting the protocol."),(0,a.kt)("h2",{id:"onchain-metadata"},"Onchain metadata"),(0,a.kt)("p",null,"To use DID identifier with onchain metadata:"),(0,a.kt)("h3",{id:"smart-contracts"},"Smart contracts"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Install or place ",(0,a.kt)("inlineCode",{parentName:"li"},"AnconProtocol.sol")),(0,a.kt)("li",{parentName:"ol"},"The NFT Dapp or App will use these calls: ",(0,a.kt)("inlineCode",{parentName:"li"},"verifyProof"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"submitPacketWithProof"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"enrollL2Account")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"updateProtocolHeader"),"."),(0,a.kt)("li",{parentName:"ol"},"Before starting, create a DID account and obtain the CID and username of the DID."),(0,a.kt)("li",{parentName:"ol"},"Execute a hybrid smart contract and send the result as input for the next call."),(0,a.kt)("li",{parentName:"ol"},"Prepare a Packet, which is the cross chain message, fill the packet message with the values returned from node API."),(0,a.kt)("li",{parentName:"ol"},"Use your recently activated DID identifier to sign the message , and send it to  ",(0,a.kt)("inlineCode",{parentName:"li"},"submitPacketWithProof")," for transaction."),(0,a.kt)("li",{parentName:"ol"},"Once proof is submitted to L1, your packet is validated and anchored.")),(0,a.kt)("h3",{id:"client"},"Client"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Use Node API to registerd DIDs."),(0,a.kt)("li",{parentName:"ol"},"Following API requires DID authentication:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Any write DAG operation (JSON or CBOR)"),(0,a.kt)("li",{parentName:"ul"},"Any hybrid smart contract transaction")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Following onchain operations requires gas and protocol fees:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"enrollL2Acccount")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"submitPacketWithProof")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"updateProtocolHeader"))),(0,a.kt)("ol",{start:4},(0,a.kt)("li",{parentName:"ol"},"Verifiable DID with KYC (only Panama) has a KYC cost to verify ID.")),(0,a.kt)("h2",{id:"anconprotocolsol"},"AnconProtocol.sol"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\nimport "../ics23/ics23.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\ncontract AnconProtocol is ICS23 {\n    bytes32 public ENROLL_PAYMENT = keccak256("ENROLL_PAYMENT");\n    bytes32 public ENROLL_DAG = keccak256("ENROLL_DAG");\n    bytes32 public SUBMIT_PAYMENT = keccak256("SUBMIT_PAYMENT");\n    // mapping(bytes32 => uint256) public p\n    address public owner;\n    address public relayer;\n\n    IERC20 public stablecoin;\n    uint256 public protocolFee = 0;\n    uint256 public accountRegistrationFee = 0;\n    uint256 public dagRegistrationFee = 0;\n    uint256 chainId = 0;\n\n    mapping(bytes => bytes) public accountProofs; //did user-assigned proof key\n    mapping(address => bytes) public accountByAddrProofs; //proof key-assigned eth address\n    mapping(bytes => bool) public proofs; //if proof key was submitted to the blockchain\n\n    mapping(bytes32 => address) public whitelistedDagGraph;\n    uint256 public seq;\n    mapping(address => uint256) public nonce;\n    mapping(bytes32 => bytes) public latestRootHashTable;\n    mapping(bytes32 => mapping(uint256 => bytes)) public relayerHashTable;\n\n    event Withdrawn(address indexed paymentAddress, uint256 amount);\n\n    event ServiceFeePaid(address indexed from, uint256 fee);\n\n    event HeaderUpdated(bytes32 indexed moniker);\n\n    event ProofPacketSubmitted(bytes key, bytes packet, bytes32 moniker);\n\n    event AccountRegistered(\n        bool enrolledStatus,\n        bytes key,\n        bytes value,\n        bytes32 moniker\n    );\n\n    constructor(address tokenAddress, uint256 network) public {\n        owner = msg.sender;\n        stablecoin = IERC20(tokenAddress);\n        chainId = network;\n    }\n\n    // getContractIdentifier is used to identify an offchain proof in any chain\n    function getContractIdentifier() public view returns (bytes32) {\n        return keccak256(abi.encodePacked(chainId, address(this)));\n    }\n\n    // getContractIdentifier is used to identify an offchain proof in any chain\n    function verifyContractIdentifier(\n        uint256 usernonce,\n        address sender,\n        bytes32 hash\n    ) public view returns (bool) {\n        return\n            keccak256(abi.encodePacked(chainId, address(this))) == hash &&\n            nonce[sender] == usernonce;\n    }\n    \n    function getNonce() public view returns (uint256) {\n        return nonce[msg.sender];\n    }\n\n    // setWhitelistedDagGraph registers offchain graphs by protocol admin\n    function setWhitelistedDagGraph(bytes32 moniker, address dagAddress)\n        public\n        payable\n    {\n        require(whitelistedDagGraph[moniker] == address(0), "exists");\n        protocolPayment(ENROLL_DAG, msg.sender);\n\n        whitelistedDagGraph[moniker] = dagAddress;\n    }\n\n    // updateRelayerHeader updates offchain dag graphs signed by dag graph key pair\n    function updateRelayerHeader(\n        bytes32 moniker,\n        bytes memory rootHash,\n        uint256 height\n    ) public {\n        require(msg.sender == whitelistedDagGraph[moniker], "invalid user");\n\n        // TODO:  Check to  see if  signer has n amount of token staked\n        relayerHashTable[moniker][height] = rootHash;\n        latestRootHashTable[moniker] = rootHash;\n\n        seq = seq + 1;\n        emit HeaderUpdated(moniker);\n    }\n\n    // setPaymentToken sets token used for protocol fees\n    function setPaymentToken(address tokenAddress) public {\n        require(owner == msg.sender);\n        stablecoin = IERC20(tokenAddress);\n}\n\n    // withdraws gas token, must be admin\n    function withdraw(address payable payee) public {\n        require(owner == msg.sender);\n        uint256 b = address(this).balance;\n        (bool sent, bytes memory data) = payee.call{value: b}("");\n        require(sent, "Failed to send Ether");\n\n        emit Withdrawn(payee, b);\n    }\n\n    // withdraws protocol fee token, must be admin\n    function withdrawToken(address payable payee, address erc20token) public {\n        require(owner == msg.sender);\n        uint256 balance = IERC20(erc20token).balanceOf(address(this));\n\n        // Transfer tokens to pay service fee\n        require(IERC20(erc20token).transfer(payee, balance), "transfer failed");\n\n        emit Withdrawn(payee, balance);\n    }\n\n    // protocolPayment handles contract payment protocol fee types\n    function protocolPayment(bytes32 paymentType, address tokenHolder)\n        internal\n    {\n        require(\n            stablecoin.balanceOf(address(tokenHolder)) > 0,\n            "no enough balance"\n        );\n        if ((paymentType) == ENROLL_DAG) {\n            require(\n                stablecoin.transferFrom(\n                    tokenHolder,\n                    address(this),\n                    dagRegistrationFee\n                ),\n                "transfer failed for recipient"\n            );\n            emit ServiceFeePaid(tokenHolder, dagRegistrationFee);\n        }\n        if ((paymentType) == ENROLL_PAYMENT) {\n            require(\n                stablecoin.transferFrom(\n                    tokenHolder,\n                    address(this),\n                    accountRegistrationFee\n                ),\n                "transfer failed for recipient"\n            );\n            emit ServiceFeePaid(tokenHolder, accountRegistrationFee);\n        }\n        if ((paymentType) == SUBMIT_PAYMENT) {\n            require(\n                stablecoin.transferFrom(\n                    tokenHolder,\n                    address(this),\n                    protocolFee\n                ),\n                "transfer failed for recipient"\n            );\n            emit ServiceFeePaid(tokenHolder, protocolFee);\n        } // Transfer tokens to pay service fee\n        nonce[tokenHolder] = nonce[tokenHolder] + 1;\n    }\n\n    function setProtocolFee(uint256 _fee) public {\n        require(owner == msg.sender);\n        protocolFee = _fee;\n    }\n\n    function setAccountRegistrationFee(uint256 _fee) public {\n        require(owner == msg.sender);\n        accountRegistrationFee = _fee;\n    }\n\n    function setDagGraphFee(uint256 _fee) public {\n        require(owner == msg.sender);\n        dagRegistrationFee = _fee;\n    }\n\n    function getProtocolHeader(bytes32 moniker)\n        public\n        view\n        returns (bytes memory)\n    {\n        return latestRootHashTable[moniker];\n    }\n\n    function getProof(bytes memory did) public view returns (bytes memory) {\n        return accountProofs[did];\n    }\n\n    function hasProof(bytes memory key) public view returns (bool) {\n        return proofs[key];\n    }\n\n    // enrollL2Account registers offchain did user onchain using ICS23 proofs, multi tenant using dag graph moniker\n    function enrollL2Account(\n        bytes32 moniker,\n        bytes memory key,\n        bytes memory did,\n        Ics23Helper.ExistenceProof memory proof\n    ) public payable returns (bool) {\n        require(keccak256(proof.key) == keccak256(key), "invalid key");\n\n        require(verifyProof(moniker, proof), "invalid proof");\n\n        require(\n            keccak256(key) != keccak256(accountProofs[did]),\n            "user already registered"\n        );\n\n        protocolPayment(ENROLL_PAYMENT, msg.sender);\n\n        accountProofs[(did)] = key;\n        accountByAddrProofs[msg.sender] = key;\n\n        emit AccountRegistered(true, key, did, moniker);\n        return true;\n    }\n\n    // submitPacketWithProof registers packet onchain using ICS23 proofs, multi tenant using dag graph moniker\n    function submitPacketWithProof(\n        bytes32 moniker,\n        address sender,\n        Ics23Helper.ExistenceProof memory userProof,\n        bytes memory key,\n        bytes memory packet,\n        Ics23Helper.ExistenceProof memory proof\n    ) external payable returns (bool) {\n        // 1. Verify\n        require(proofs[key] == false, "proof has been submitted (found key)");\n        require(keccak256(proof.key) == keccak256(key), "invalid key");\n        require(\n            keccak256(accountByAddrProofs[sender]) == keccak256(userProof.key),\n            "invalid user key"\n        );\n        require(verifyProof(moniker, userProof), "invalid user proof");\n        require(verifyProof(moniker, proof));\n\n        proofs[key] = true;\n\n        protocolPayment(SUBMIT_PAYMENT, sender);\n\n        // 2. Submit event\n        emit ProofPacketSubmitted(key, packet, moniker);\n\n        return true;\n    }\n\n    // verifies ICS23 proofs, multi tenant using dag graph moniker\n    function verifyProof(\n        bytes32 moniker,\n        Ics23Helper.ExistenceProof memory exProof\n    ) internal view returns (bool) {\n        // Verify membership\n        verify(\n            exProof,\n            getIavlSpec(),\n            latestRootHashTable[moniker],\n            exProof.key,\n            exProof.value\n        );\n\n        return true;\n    }\n\n    // verifies ICS23 proofs with key and value, multi tenant using dag graph moniker\n    function verifyProofWithKV(\n        bytes32 moniker,\n        bytes memory key,\n        bytes memory value,\n        Ics23Helper.ExistenceProof memory exProof\n    ) external view returns (bool) {\n        // Verify membership\n        verify(\n            exProof,\n            getIavlSpec(),\n            latestRootHashTable[moniker],\n            key,\n            value\n        );\n\n        return true;\n    }\n\n    // calculates root hash\n    function queryRootCalculation(Ics23Helper.ExistenceProof memory proof)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bytes(calculate(proof));\n    }\n}\n')),(0,a.kt)("h2",{id:"metadata-json-schema"},"Metadata JSON Schema"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "$schema": "https://json-schema.org/draft/2020-12/schema",\n  "$id": "https://ancon.did.pa/v0/protocol/metadata",\n  "title": "metadata",\n  "description": "Ancon Protocol metadata schema",\n  "type": "object",\n  "properties": {\n      "name": {\n          "type": "string",\n          "description": "Identifies the asset to which this token represents",\n      },\n      "description": {\n          "type": "string",\n          "description": "Describes the asset to which this token represents",\n      },\n      "image": {\n          "type": "string",\n          "description": "A URI pointing to a resource with mime type image/* representing the asset to which this token represents.",\n      },\n      "sources": {\n          "type": "cid array",\n          "description": "Current intellectual property",\n      },\n      "owner": {\n          "type": "string",\n          "description": "The owner is a DID identifier",\n      },\n      "parent": {\n          "type": "cid",\n          "description": "Direct ascendant of the current intellectual property",\n      }\n  },\n  "required": [ "name", "description", "image", "sources" ]\n}\n')),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-JavaScript"},'\nconst payload = {\n  "name": "XDV metadata sample",\n  "description": "testing sample",\n  "image": "https://explore.ipld.io/#/explore/QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D",\n  "sources": [\n    "QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D",\n    "z8mWaJHXieAVxxLagBpdaNWFEBKVWmMiE",\n    "QmdmQXB2mzChmMeKY47C43LxUdg1NDJ5MWcKMKxDu7RgQm",\n  ],\n};\n\n\n')))}u.isMDXComponent=!0}}]);