"use strict";(self.webpackChunkancon_docs=self.webpackChunkancon_docs||[]).push([[615],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=r.createContext({}),c=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(d.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,d=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(t),m=i,y=p["".concat(d,".").concat(m)]||p[m]||l[m]||o;return t?r.createElement(y,a(a({ref:n},u),{},{components:t})):r.createElement(y,a({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=p;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<o;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},2801:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return d},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var r=t(7462),i=t(3366),o=(t(7294),t(3905)),a=["components"],s={sidebar_position:2},d="Using a Verifiable DAG store",c={unversionedId:"api/metadata",id:"api/metadata",isDocsHomePage:!1,title:"Using a Verifiable DAG store",description:"Ancon Protocol Node is an Layer 2, offchain DAG Store with verifiable data. Anyone can use it once they registered a DID with the L2, which will generate a vector commitment proof, if indeed the register exists or not in the merkle tree.",source:"@site/docs/api/metadata.md",sourceDirName:"api",slug:"/api/metadata",permalink:"/docs/api/metadata",editUrl:"https://github.com/anconprotocol/ancon-docs/docs/api/metadata.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"API Reference",permalink:"/docs/api/reference"},next:{title:"Trusted offchain gateways",permalink:"/docs/api/durin"}},u=[{value:"AnconProtocol.sol",id:"anconprotocolsol",children:[],level:2},{value:"Metadata JSON Schema",id:"metadata-json-schema",children:[{value:"Example",id:"example",children:[],level:3}],level:2}],l={toc:u};function p(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"using-a-verifiable-dag-store"},"Using a Verifiable DAG store"),(0,o.kt)("p",null,"Ancon Protocol Node is an Layer 2, offchain DAG Store with verifiable data. Anyone can use it once they registered a DID with the L2, which will generate a vector commitment proof, if indeed the register exists or not in the merkle tree."),(0,o.kt)("p",null,"Because there is no consensus involved, we can only be sure that it was signed by someone using a DID identifier. To be able to have a more decentralized feature, is recommended to anchor both DID and proofs in a ICS23 Vector Commitment compatible smart contract chain."),(0,o.kt)("p",null,"Once is submitted to a onchain solution, any offchain operation can be properly validated onchain for any proofs."),(0,o.kt)("h2",{id:"anconprotocolsol"},"AnconProtocol.sol"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\nimport "../ics23/ics23.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\ncontract AnconProtocol is ICS23 {\n    struct SubscriptionTier {\n        address token;\n        uint256 amount;\n        uint256 amountStaked;\n        uint256 includedBlocks;\n        bytes32 id;\n        uint256 incentiveBlocksMonthly;\n        uint256 incentivePercentageMonthly;\n        uint256 includedBlocksStarted;\n    }\n    address public owner;\n    address public relayer;\n\n    IERC20 public stablecoin;\n    uint256 public protocolFee = 0;\n    uint256 public accountRegistrationFee = 0;\n    uint256 public dagRegistrationFee = 0;\n    uint256 chainId = 0;\n\n    mapping(bytes => bytes) public accountProofs; //did user-assigned proof key\n    mapping(address => bytes) public accountByAddrProofs; //proof key-assigned eth address\n    mapping(bytes => bool) public proofs; //if proof key was submitted to the blockchain\n\n    mapping(bytes32 => address) public whitelistedDagGraph;\n    mapping(bytes32 => SubscriptionTier) public tiers;\n    mapping(address => SubscriptionTier) public dagGraphSubscriptions;\n    mapping(address => uint256) public totalHeaderUpdatesByDagGraph;\n    mapping(address => mapping(address => uint256))\n        public totalSubmittedByDagGraphUser;\n\n    uint256 public seq;\n    mapping(address => uint256) public nonce;\n    mapping(bytes32 => bytes) public latestRootHashTable;\n    mapping(bytes32 => mapping(uint256 => bytes)) public relayerHashTable;\n    uint256 public INCLUDED_BLOCKS_EPOCH = 200000; // 200 000 chain blocks\n\n    event Withdrawn(address indexed paymentAddress, uint256 amount);\n\n    event ServiceFeePaid(\n        address indexed from,\n        bytes32 indexed tier,\n        bytes32 indexed moniker,\n        address token,\n        uint256 fee\n    );\n\n    event HeaderUpdated(bytes32 indexed moniker);\n\n    event ProofPacketSubmitted(\n        bytes indexed key,\n        bytes packet,\n        bytes32 moniker\n    );\n\n    event TierAdded(bytes32 indexed id);\n\n    event TierUpdated(\n        bytes32 indexed id,\n        address token,\n        uint256 fee,\n        uint256 staked,\n        uint256 includedBlocks\n    );\n\n    event AccountRegistered(\n        bool enrolledStatus,\n        bytes key,\n        bytes value,\n        bytes32 moniker\n    );\n\n    constructor(\n        address tokenAddress,\n        uint256 network,\n        uint256 starterFee,\n        uint256 startupFee\n    ) public {\n        owner = msg.sender;\n        stablecoin = IERC20(tokenAddress);\n        chainId = network;\n\n        // add tiers\n        addTier(keccak256("starter"), tokenAddress, starterFee, 0, 100);\n        addTier(keccak256("startup"), tokenAddress, startupFee, 0, 500);\n        addTier(keccak256("pro"), tokenAddress, 0, 0, 1000);\n        setTierSettings(\n            keccak256("pro"),\n            tokenAddress,\n            500000000,\n            1000 ether,\n            1000\n        );\n        addTier(keccak256("defi"), tokenAddress, 0, 0, 10000);\n        addTier(keccak256("luxury"), tokenAddress, 0, 0, 100000);\n    }\n\n    // getContractIdentifier is used to identify a contract protocol deployed in a specific chain\n    function getContractIdentifier() public view returns (bytes32) {\n        return keccak256(abi.encodePacked(chainId, address(this)));\n    }\n\n    // verifyContractIdentifier verifies a nonce is from  a specific chain\n    function verifyContractIdentifier(\n        uint256 usernonce,\n        address sender,\n        bytes32 hash\n    ) public view returns (bool) {\n        return\n            keccak256(abi.encodePacked(chainId, address(this))) == hash &&\n            nonce[sender] == usernonce;\n    }\n\n    function getNonce() public view returns (uint256) {\n        return nonce[msg.sender];\n    }\n\n    // registerDagGraphTier\n    function registerDagGraphTier(\n        bytes32 moniker,\n        address dagAddress,\n        bytes32 tier\n    ) public payable {\n        require(whitelistedDagGraph[moniker] == address(0), "moniker exists");\n        require(tier == tiers[tier].id, "missing tier");\n\n        whitelistedDagGraph[moniker] = dagAddress;\n        dagGraphSubscriptions[dagAddress] = tiers[tier];\n    }\n\n    // updateRelayerHeader updates offchain dag graphs signed by dag graph key pair\n    function updateRelayerHeader(\n        bytes32 moniker,\n        bytes memory rootHash,\n        uint256 height\n    ) public payable {\n        require(msg.sender == whitelistedDagGraph[moniker], "invalid user");\n\n        SubscriptionTier memory t = dagGraphSubscriptions[msg.sender];\n        IERC20 token = IERC20(tiers[t.id].token);\n        require(token.balanceOf(address(msg.sender)) > 0, "no enough balance");\n\n        if (t.includedBlocks > 0) {\n            t.includedBlocks = t.includedBlocks - 1;\n        } else {\n            // tier has no more free blocks for this epoch, charge protocol fee\n            require(\n                token.transferFrom(msg.sender, address(this), tiers[t.id].amount),\n                "transfer failed for recipient"\n            );\n        }\n        // reset tier includede blocks every elapsed epoch\n        uint256 elapsed = block.number - t.includedBlocksStarted;\n        if (elapsed > INCLUDED_BLOCKS_EPOCH) {\n            // must always read from latest tier settings\n            t.includedBlocks = tiers[t.id].includedBlocks;\n            t.includedBlocksStarted = block.number;\n        }\n        // set hash\n        relayerHashTable[moniker][height] = rootHash;\n        latestRootHashTable[moniker] = rootHash;\n        emit ServiceFeePaid(msg.sender, moniker, t.id, tiers[t.id].token, tiers[t.id].amount);\n\n        seq = seq + 1;\n        totalHeaderUpdatesByDagGraph[msg.sender] = totalHeaderUpdatesByDagGraph[msg.sender] + 1;\n        emit HeaderUpdated(moniker);\n    }\n\n    // setPaymentToken sets token used for protocol fees\n    function setPaymentToken(address tokenAddress) public {\n        require(owner == msg.sender);\n        stablecoin = IERC20(tokenAddress);\n    }\n\n    // addTier\n    function addTier(\n        bytes32 id,\n        address tokenAddress,\n        uint256 amount,\n        uint256 amountStaked,\n        uint256 includedBlocks\n    ) public {\n        require(owner == msg.sender, "invalid owner");\n        require(tiers[id].id != id, "tier already in use");\n        tiers[id] = SubscriptionTier({\n            token: tokenAddress,\n            amount: amount,\n            amountStaked: amountStaked,\n            includedBlocks: includedBlocks,\n            id: id,\n            incentiveBlocksMonthly: 0,\n            incentivePercentageMonthly: 0,\n            includedBlocksStarted: block.number\n        });\n        emit TierAdded(id);\n    }\n\n    // setTierSettings\n    function setTierSettings(\n        bytes32 id,\n        address tokenAddress,\n        uint256 amount,\n        uint256 amountStaked,\n        uint256 includedBlocks\n    ) public {\n        require(owner == msg.sender, "invalid owner");\n        require(tiers[id].id == id, "missing tier");\n        tiers[id].token = tokenAddress;\n        tiers[id].amount = amount;\n        tiers[id].amountStaked = amountStaked;\n        tiers[id].includedBlocks = includedBlocks;\n        // incentiveBlocksMonthly: 0,\n        // incentivePercentageMonthly: 0\n        emit TierUpdated(\n            id,\n            tokenAddress,\n            amount,\n            amountStaked,\n            includedBlocks\n        );\n    }\n\n    // withdraws gas token, must be admin\n    function withdraw(address payable payee) public {\n        require(owner == msg.sender);\n        uint256 b = address(this).balance;\n        (bool sent, bytes memory data) = payee.call{value: b}("");\n        require(sent, "Failed to send Ether");\n\n        emit Withdrawn(payee, b);\n    }\n\n    // withdraws protocol fee token, must be admin\n    function withdrawToken(address payable payee, address erc20token) public {\n        require(owner == msg.sender);\n        uint256 balance = IERC20(erc20token).balanceOf(address(this));\n\n        // Transfer tokens to pay service fee\n        require(IERC20(erc20token).transfer(payee, balance), "transfer failed");\n\n        emit Withdrawn(payee, balance);\n    }\n\n\n    function getProtocolHeader(bytes32 moniker)\n        public\n        view\n        returns (bytes memory)\n    {\n        return latestRootHashTable[moniker];\n    }\n\n    function getProof(bytes memory did) public view returns (bytes memory) {\n        return accountProofs[did];\n    }\n\n    function hasProof(bytes memory key) public view returns (bool) {\n        return proofs[key];\n    }\n\n    // enrollL2Account registers offchain did user onchain using ICS23 proofs, multi tenant using dag graph moniker\n    function enrollL2Account(\n        bytes32 moniker,\n        bytes memory key,\n        bytes memory did,\n        Ics23Helper.ExistenceProof memory proof\n    ) public returns (bool) {\n        require(keccak256(proof.key) == keccak256(key), "invalid key");\n\n        require(verifyProof(moniker, proof), "invalid proof");\n\n        require(\n            keccak256(key) != keccak256(accountProofs[did]),\n            "user already registered"\n        );\n\n        totalSubmittedByDagGraphUser[whitelistedDagGraph[moniker]][msg.sender] = totalSubmittedByDagGraphUser[whitelistedDagGraph[moniker]][msg.sender] + 1;\n        accountProofs[(did)] = key;\n        accountByAddrProofs[msg.sender] = key;\n\n        emit AccountRegistered(true, key, did, moniker);\n        return true;\n    }\n\n    // submitPacketWithProof registers packet onchain using ICS23 proofs, multi tenant using dag graph moniker\n    function submitPacketWithProof(\n        bytes32 moniker,\n        address sender,\n        Ics23Helper.ExistenceProof memory userProof,\n        bytes memory key,\n        bytes memory packet,\n        Ics23Helper.ExistenceProof memory proof\n    ) external returns (bool) {\n        // 1. Verify\n        require(proofs[key] == false, "proof has been submitted (found key)");\n        require(keccak256(proof.key) == keccak256(key), "invalid key");\n        require(\n            keccak256(accountByAddrProofs[sender]) == keccak256(userProof.key),\n            "invalid user key"\n        );\n        require(verifyProof(moniker, userProof), "invalid user proof");\n        require(verifyProof(moniker, proof));\n\n        proofs[key] = true;\n\n        // 2. Submit event\n        emit ProofPacketSubmitted(key, packet, moniker);\n\n        return true;\n    }\n\n    // verifies ICS23 proofs, multi tenant using dag graph moniker\n    function verifyProof(\n        bytes32 moniker,\n        Ics23Helper.ExistenceProof memory exProof\n    ) internal view returns (bool) {\n        // Verify membership\n        verify(\n            exProof,\n            getIavlSpec(),\n            latestRootHashTable[moniker],\n            exProof.key,\n            exProof.value\n        );\n\n        return true;\n    }\n\n    // verifies ICS23 proofs with key and value, multi tenant using dag graph moniker\n    function verifyProofWithKV(\n        bytes32 moniker,\n        bytes memory key,\n        bytes memory value,\n        Ics23Helper.ExistenceProof memory exProof\n    ) external view returns (bool) {\n        // Verify membership\n        verify(\n            exProof,\n            getIavlSpec(),\n            latestRootHashTable[moniker],\n            key,\n            value\n        );\n\n        return true;\n    }\n\n    // calculates root hash\n    function queryRootCalculation(Ics23Helper.ExistenceProof memory proof)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bytes(calculate(proof));\n    }\n}\n\n')),(0,o.kt)("h2",{id:"metadata-json-schema"},"Metadata JSON Schema"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "$schema": "https://json-schema.org/draft/2020-12/schema",\n  "$id": "https://ancon.did.pa/v0/protocol/metadata",\n  "title": "metadata",\n  "description": "Ancon Protocol metadata schema",\n  "type": "object",\n  "properties": {\n      "name": {\n          "type": "string",\n          "description": "Identifies the asset to which this token represents",\n      },\n      "description": {\n          "type": "string",\n          "description": "Describes the asset to which this token represents",\n      },\n      "image": {\n          "type": "string",\n          "description": "A URI pointing to a resource with mime type image/* representing the asset to which this token represents.",\n      },\n      "sources": {\n          "type": "cid array",\n          "description": "Current intellectual property",\n      },\n      "owner": {\n          "type": "string",\n          "description": "The owner is a DID identifier",\n      },\n      "parent": {\n          "type": "cid",\n          "description": "Direct ascendant of the current intellectual property",\n      }\n  },\n  "required": [ "name", "description", "image", "sources" ]\n}\n')),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-JavaScript"},'\nconst payload = {\n  "name": "XDV metadata sample",\n  "description": "testing sample",\n  "image": "https://explore.ipld.io/#/explore/QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D",\n  "sources": [\n    "QmSnuWmxptJZdLJpKRarxBMS2Ju2oANVrgbr2xWbie9b2D",\n    "z8mWaJHXieAVxxLagBpdaNWFEBKVWmMiE",\n    "QmdmQXB2mzChmMeKY47C43LxUdg1NDJ5MWcKMKxDu7RgQm",\n  ],\n};\n\n\n')))}p.isMDXComponent=!0}}]);