"use strict";(self.webpackChunkancon_docs=self.webpackChunkancon_docs||[]).push([[688],{3905:function(n,e,t){t.d(e,{Zo:function(){return u},kt:function(){return f}});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var d=r.createContext({}),c=function(n){var e=r.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},u=function(n){var e=c(n.components);return r.createElement(d.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},l=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,i=n.originalType,d=n.parentName,u=s(n,["components","mdxType","originalType","parentName"]),l=c(t),f=a,g=l["".concat(d,".").concat(f)]||l[f]||p[f]||i;return t?r.createElement(g,o(o({ref:e},u),{},{components:t})):r.createElement(g,o({ref:e},u))}));function f(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var i=t.length,o=new Array(i);o[0]=l;var s={};for(var d in e)hasOwnProperty.call(e,d)&&(s[d]=e[d]);s.originalType=n,s.mdxType="string"==typeof n?n:a,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}l.displayName="MDXCreateElement"},2143:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return s},contentTitle:function(){return d},metadata:function(){return c},toc:function(){return u},default:function(){return l}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),o=["components"],s={sidebar_position:3},d="Trusted offchain gateways",c={unversionedId:"api/durin",id:"api/durin",isDocsHomePage:!1,title:"Trusted offchain gateways",description:"Ancon Protocol node can be used to integrate onchain and offchain sources using EIP-3668 Durin or also called Trusted Offchain gateway. Further in Subgraph networks chapter, we'll revisit this feature as we replace REST with Graphsync.",source:"@site/docs/api/durin.md",sourceDirName:"api",slug:"/api/durin",permalink:"/docs/api/durin",editUrl:"https://github.com/anconprotocol/ancon-docs/docs/api/durin.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Using a Verifiable DAG store",permalink:"/docs/api/metadata"},next:{title:"IPLD Operations",permalink:"/docs/api/ipld"}},u=[{value:"What is trustless and trusted",id:"what-is-trustless-and-trusted",children:[],level:2},{value:"Design and Architecture of a Hybrid Smart Contract",id:"design-and-architecture-of-a-hybrid-smart-contract",children:[],level:2},{value:"Create Rust GraphQL Query and Mutations",id:"create-rust-graphql-query-and-mutations",children:[],level:2},{value:"DAG Operations or Mutation",id:"dag-operations-or-mutation",children:[],level:2},{value:"Smart Contract APIs",id:"smart-contract-apis",children:[{value:"<code>pub fn focused_transform_patch_str(cid: &amp;str, path: &amp;str, prev: &amp;str, next: &amp;str) -&gt; String</code>",id:"pub-fn-focused_transform_patch_strcid-str-path-str-prev-str-next-str---string",children:[],level:3},{value:"<code>pub fn read_dag(cid: &amp;str) -&gt; Vec&lt;u8&gt;</code>",id:"pub-fn-read_dagcid-str---vecu8",children:[],level:3},{value:"<code>pub fn submit_proof(data: &amp;str) -&gt; String</code>",id:"pub-fn-submit_proofdata-str---string",children:[],level:3},{value:"<code>pub fn get_proof(cid: &amp;str) -&gt; String</code>",id:"pub-fn-get_proofcid-str---string",children:[],level:3},{value:"<code>pub fn generate_proof(cid: &amp;str) -&gt; String</code>",id:"pub-fn-generate_proofcid-str---string",children:[],level:3}],level:2},{value:"Onchain adapter",id:"onchain-adapter",children:[],level:2},{value:"Generate client bindings for schemas",id:"generate-client-bindings-for-schemas",children:[],level:2}],p={toc:u};function l(n){var e=n.components,t=(0,a.Z)(n,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"trusted-offchain-gateways"},"Trusted offchain gateways"),(0,i.kt)("p",null,"Ancon Protocol node can be used to integrate onchain and offchain sources using EIP-3668 Durin or also called Trusted Offchain gateway. Further in ",(0,i.kt)("inlineCode",{parentName:"p"},"Subgraph networks")," chapter, we'll revisit this feature as we replace REST with Graphsync."),(0,i.kt)("h2",{id:"what-is-trustless-and-trusted"},"What is trustless and trusted"),(0,i.kt)("p",null,"A trustless setting onchain means the consensus of a blockchain is enough to validate a transaction is valid and has no bad behavior."),(0,i.kt)("p",null,"In cross chain use cases, there are many to accomplish this, one is with atomic swaps, whichi we'll use in parts, other is with ZK technology and other with protocols that are based on Merkle Proofs."),(0,i.kt)("h2",{id:"design-and-architecture-of-a-hybrid-smart-contract"},"Design and Architecture of a Hybrid Smart Contract"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Hybrid Smart Contracts")," is the term used for integrating both offchain and onchain seamlessly in a secure way. To start using the Node SDK."),(0,i.kt)("p",null,"The Node SDK uses a set of technologies, the developer should have a good grasp of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Go language"),(0,i.kt)("li",{parentName:"ul"},"IPLD"),(0,i.kt)("li",{parentName:"ul"},"GraphQL"),(0,i.kt)("li",{parentName:"ul"},"Rust")),(0,i.kt)("h2",{id:"create-rust-graphql-query-and-mutations"},"Create Rust GraphQL Query and Mutations"),(0,i.kt)("p",null,"Download the ",(0,i.kt)("inlineCode",{parentName:"p"},"github.com/anconprotocol/contracts")," and label it with the name of your project."),(0,i.kt)("p",null,"The current source code has an example of a onchain DID ownership trasfer for ERC721 tokens."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::sdk::focused_transform_patch_str;\nuse crate::sdk::read_dag;\nuse crate::sdk::submit_proof;\nuse crate::sdk::{generate_proof, get_proof, read_dag_block, write_dag_block};\nuse juniper::FieldResult;\n\nextern crate juniper;\n\nuse juniper::{\n    graphql_object, EmptyMutation, EmptySubscription, FieldError, GraphQLEnum, GraphQLValue,\n    RootNode, Variables,\n};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\n\nuse std::collections::HashMap;\n\nuse std::str;\nuse std::vec::*;\n\npub struct Context {\n    pub metadata: HashMap<String, Ancon721Metadata>,\n    pub transfer: HashMap<String, MetadataPacket>,\n}\n\nimpl juniper::Context for Context {}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct MetadataPacket {\n    pub cid: String,\n    pub from_owner: String,\n    pub result_cid: String,\n    pub to_owner: String,\n    pub to_address: String,\n    pub token_id: String,\n    pub proof: String,\n}\n\n#[graphql_object(context = Context)]\nimpl MetadataPacket {\n    fn cid(&self) -> &str {\n        &self.cid\n    }\n\n    fn from_owner(&self) -> &str {\n        &self.from_owner\n    }\n\n    fn result_cid(&self) -> &str {\n        &self.result_cid\n    }\n    fn to_owner(&self) -> &str {\n        &self.to_owner\n    }\n\n    fn to_address(&self) -> &str {\n        &self.to_address\n    }\n\n    fn token_id(&self) -> &str {\n        &self.token_id\n    }\n    fn proof(&self) -> &str {\n        &self.proof\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct Ancon721Metadata {\n    pub name: String,\n    pub description: String,\n    pub image: String,\n    pub parent: String,\n    pub owner: String,\n    pub sources: Vec<String>,\n}\n\n#[graphql_object(context = Context)]\nimpl Ancon721Metadata {\n    fn name(&self) -> &str {\n        &self.name\n    }\n\n    fn description(&self) -> &str {\n        &self.description\n    }\n\n    fn image(&self) -> &str {\n        &self.image\n    }\n    fn parent(&self) -> &str {\n        &self.parent\n    }\n\n    fn owner(&self) -> &str {\n        &self.owner\n    }\n\n    async fn sources(&self) -> &Vec<String> {\n        &self.sources\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct Query;\n\n#[graphql_object(context = Context)]\nimpl Query {\n    fn api_version() -> &\'static str {\n        "0.1"\n    }\n\n    pub fn metadata(context: &Context, cid: String, path: String) -> Ancon721Metadata {\n        let v = read_dag(&cid);\n        let res = serde_json::from_slice(&v);\n        res.unwrap()\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\npub struct Mutation;\n\n#[graphql_object(context = Context)]\nimpl Mutation {\n    //Dagblock mutation\n    fn transfer(context: &Context, input: MetadataTransactionInput) -> Vec<MetadataPacket> {\n        let v = read_dag(&input.cid);\n        let res = serde_json::from_slice(&v);\n        let metadata: Ancon721Metadata = res.unwrap();\n\n        //generate current metadata proof packet\n        let proof = generate_proof(&input.cid);\n\n        let updated_cid =\n            focused_transform_patch_str(&input.cid, "owner", &metadata.owner, &input.new_owner);\n        let updated =\n            focused_transform_patch_str(&updated_cid, "parent", &metadata.parent, &input.cid);\n\n        //generate updated metadata proof packet\n        let proof_cid = apply_request_with_proof(input.clone(), &proof, &updated);\n        let v = read_dag(&proof_cid);\n        let res = serde_json::from_slice(&v);\n        let packet: MetadataPacket = res.unwrap();\n        let current_packet = MetadataPacket {\n            cid: input.cid,\n            from_owner: input.owner,\n            result_cid: updated,\n            to_address: "".to_string(),\n            to_owner: input.new_owner,\n            token_id: "".to_string(),\n            proof: proof,\n        };\n        let result = vec![current_packet, packet];\n        result\n    }\n}\n\n#[derive(Clone, Debug, GraphQLInputObject, Serialize, Deserialize)]\nstruct MetadataTransactionInput {\n    path: String,\n    cid: String,\n    owner: String,\n    new_owner: String,\n}\n\ntype Schema = RootNode<\'static, Query, Mutation, EmptySubscription<Context>>;\n\npub fn schema() -> Schema {\n    Schema::new(Query, Mutation, EmptySubscription::<Context>::new())\n}\n\nfn apply_request_with_proof(\n    input: MetadataTransactionInput,\n    prev_proof: &str,\n    new_cid: &str,\n) -> String {\n    // Must combined proofs (prev and new) in host function\n    // then send to chain and return result\n    let js = json!({\n        "previous": prev_proof,\n        "next_cid": new_cid,\n        "input": input\n    });\n    submit_proof(&js.to_string())\n}\n')),(0,i.kt)("h2",{id:"dag-operations-or-mutation"},"DAG Operations or Mutation"),(0,i.kt)("p",null,"Now we are going to apply a GraphQL mutation, which is an update to an immutable object, means it will discard the old CID and create a new CID from the latest update in the DAG block. "),(0,i.kt)("p",null,"Why are we abstracting on top of GraphQL? The main reason is to provide a better and more expedite approach to software engineering differents pieces of technologies like IPFS and blockchain. By enforcing the schemas with code generation in server side, we also get a similar developer experience as when you do smart contract development. "),(0,i.kt)("p",null,"In this example, we'll use one of the easiest IPLD Operator, which is the ",(0,i.kt)("inlineCode",{parentName:"p"},"focused transform"),", where we "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pinpoint or ",(0,i.kt)("strong",{parentName:"li"},"select")," a path inside a root node"),(0,i.kt)("li",{parentName:"ul"},"Patch or mutate that selection with a function call. In our case, a diff patch, eg if previous node matches previous node requested a change, then apply requested change to node.")),(0,i.kt)("p",null,"In Ancon Protocol Contracts SDK, you can use focused transform with ",(0,i.kt)("inlineCode",{parentName:"p"},"focused_transform_patch_str")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'\n#[derive(Clone, Copy, Debug)]\npub struct Mutation;\n\n#[graphql_object(context = Context)]\nimpl Mutation {\n    //Dagblock mutation\n    fn transfer(context: &Context, input: MetadataTransactionInput) -> Vec<MetadataPacket> {\n        let v = read_dag(&input.cid);\n        let res = serde_json::from_slice(&v);\n        let metadata: Ancon721Metadata = res.unwrap();\n\n        //generate current metadata proof packet\n        let proof = generate_proof(&input.cid);\n\n        let updated_cid =\n            focused_transform_patch_str(&input.cid, "owner", &metadata.owner, &input.new_owner);\n        let updated =\n            focused_transform_patch_str(&updated_cid, "parent", &metadata.parent, &input.cid);\n\n        //generate updated metadata proof packet\n        let proof_cid = apply_request_with_proof(input.clone(), &proof, &updated);\n        let v = read_dag(&proof_cid);\n        let res = serde_json::from_slice(&v);\n        let packet: MetadataPacket = res.unwrap();\n        let current_packet = MetadataPacket {\n            cid: input.cid,\n            from_owner: input.owner,\n            result_cid: updated,\n            to_address: "".to_string(),\n            to_owner: input.new_owner,\n            token_id: "".to_string(),\n            proof: proof,\n        };\n        let result = vec![current_packet, packet];\n        result\n    }\n}\n\n#[derive(Clone, Debug, GraphQLInputObject, Serialize, Deserialize)]\nstruct MetadataTransactionInput {\n    path: String,\n    cid: String,\n    owner: String,\n    new_owner: String,\n}\n\n\n')),(0,i.kt)("p",null,"The result must always be the previous and next packets."),(0,i.kt)("h2",{id:"smart-contract-apis"},"Smart Contract APIs"),(0,i.kt)("h3",{id:"pub-fn-focused_transform_patch_strcid-str-path-str-prev-str-next-str---string"},(0,i.kt)("inlineCode",{parentName:"h3"},"pub fn focused_transform_patch_str(cid: &str, path: &str, prev: &str, next: &str) -> String")),(0,i.kt)("p",null,"Applies an IPLD focused transform using a patch design pattern for string node values"),(0,i.kt)("h3",{id:"pub-fn-read_dagcid-str---vecu8"},(0,i.kt)("inlineCode",{parentName:"h3"},"pub fn read_dag(cid: &str) -> Vec<u8>")),(0,i.kt)("p",null,"Reads a cid from dag store"),(0,i.kt)("h3",{id:"pub-fn-submit_proofdata-str---string"},(0,i.kt)("inlineCode",{parentName:"h3"},"pub fn submit_proof(data: &str) -> String")),(0,i.kt)("p",null,"Submits proof (offchain)"),(0,i.kt)("h3",{id:"pub-fn-get_proofcid-str---string"},(0,i.kt)("inlineCode",{parentName:"h3"},"pub fn get_proof(cid: &str) -> String")),(0,i.kt)("p",null,"Retrieves proof (offchain)"),(0,i.kt)("h3",{id:"pub-fn-generate_proofcid-str---string"},(0,i.kt)("inlineCode",{parentName:"h3"},"pub fn generate_proof(cid: &str) -> String")),(0,i.kt)("p",null,"Generates proof (offchain)"),(0,i.kt)("h2",{id:"onchain-adapter"},"Onchain adapter"),(0,i.kt)("p",null,"The adapter gets called through Node SDK JSON-RPC 2.0 endpoint."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package transfer\n\nimport (\n    "bytes"\n    "context"\n    "crypto/ecdsa"\n    "encoding/hex"\n    "fmt"\n    "math/big"\n\n    "github.com/ethereum/go-ethereum/accounts/abi"\n    "github.com/ethereum/go-ethereum/common/hexutil"\n    "github.com/ethereum/go-ethereum/common/math"\n    "github.com/ethereum/go-ethereum/crypto"\n)\n\nfunc SignedProofAbiMethod() abi.Method {\n\n    // uint256Type, _ := abi.NewType("uint256", "", nil)\n    uintType, _ := abi.NewType("uint", "", nil)\n    bytesType, _ := abi.NewType("bytes", "", nil)\n    stringType, _ := abi.NewType("string", "", nil)\n    request := abi.NewMethod(\n        "transferURIWithProof",\n        "transferURIWithProof",\n        abi.Function,\n        "nonpayable",\n        false,\n        false,\n        abi.Arguments{{\n            Name:    "metadataCid",\n            Type:    stringType,\n            Indexed: false,\n        },\n            {\n                Name:    "fromOwner",\n                Type:    stringType,\n                Indexed: false,\n            },\n            {\n                Name:    "resultCid",\n                Type:    stringType,\n                Indexed: false,\n            },\n            {\n                Name:    "toOwner",\n                Type:    stringType,\n                Indexed: false,\n            },\n            {\n                Name:    "toAddress",\n                Type:    stringType,\n                Indexed: false,\n            },\n            {\n                Name:    "tokenId",\n                Type:    stringType,\n                Indexed: false,\n            },\n            {\n                Name:    "prefix",\n                Type:    stringType,\n                Indexed: false,\n            },\n            {\n                Name:    "signature",\n                Type:    bytesType,\n                Indexed: false,\n            },\n        },\n        abi.Arguments{abi.Argument{\n            Type: uintType,\n        }},\n    )\n\n    return request\n}\n\ntype OnchainAdapter struct {\n    PrivateKey *ecdsa.PrivateKey\n    ChainName  string\n    ChainID    int\n}\n\nfunc NewOnchainAdapter(pk *ecdsa.PrivateKey) OnchainAdapter {\n\n    return OnchainAdapter{\n        PrivateKey: pk,\n        ChainName:  "Ethereum",\n        ChainID:    5,\n    }\n}\n\n// https://gist.github.com/miguelmota/bc4304bb21a8f4cc0a37a0f9347b8bbb\nfunc encodePacked(input ...[]byte) []byte {\n    return bytes.Join(input, nil)\n}\n\nfunc encodeBytesString(v string) []byte {\n    decoded, err := hex.DecodeString(v)\n    if err != nil {\n        panic(err)\n    }\n    return decoded\n}\n\nfunc encodeUint256(v string) []byte {\n    bn := new(big.Int)\n    bn.SetString(v, 10)\n    return math.U256Bytes(bn)\n}\n\nfunc encodeUint256Array(arr []string) []byte {\n    var res [][]byte\n    for _, v := range arr {\n        b := encodeUint256(v)\n        res = append(res, b)\n    }\n\n    return bytes.Join(res, nil)\n}\nfunc (adapter *OnchainAdapter) ApplyRequestWithProof(\n    ctx context.Context,\n    metadataCid string,\n    resultCid string,\n    fromOwner string,\n    toOwner string,\n    toAddress string,\n    tokenId string,\n    prefix string,\n) (hexutil.Bytes, string, error) {\n\n    id := (tokenId)\n    unsignedProofData := encodePacked(\n        []byte("\\x19Ethereum Signed Message:\\n32"),\n        // Proof\n        crypto.Keccak256(encodePacked(\n            // Current metadata cid\n            []byte(metadataCid),\n            // Current owner (opaque)\n            []byte(fromOwner),\n            // Updated metadata cid\n            []byte(resultCid),\n            // New owner address\n            []byte(toOwner),\n            // Token Address\n            []byte(toAddress),\n            // Token Id\n            []byte(id),\n            // Contract Prefix\n            []byte(prefix)),\n        ))\n\n    hash := crypto.Keccak256Hash(unsignedProofData)\n\n    signature, err := crypto.Sign(hash.Bytes(), adapter.PrivateKey)\n    if err != nil {\n        return nil, "", fmt.Errorf("signing failed")\n    }\n\n    signedProofData, err := SignedProofAbiMethod().Inputs.Pack(\n        metadataCid, fromOwner, resultCid, toOwner, toAddress, id, prefix, signature)\n\n    if err != nil {\n        return nil, "", fmt.Errorf("packing for signature proof generation failed")\n    }\n\n    return signedProofData, resultCid, nil\n}\n\n')),(0,i.kt)("h2",{id:"generate-client-bindings-for-schemas"},"Generate client bindings for schemas"),(0,i.kt)("p",null,"Run ",(0,i.kt)("inlineCode",{parentName:"p"},"generateClientModels.sh")," and then update   ",(0,i.kt)("inlineCode",{parentName:"p"},"durin.go")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'\npackage durin\n\nimport (\n    "context"\n    "encoding/json"\n    "fmt"\n\n    "github.com/anconprotocol/node/adapters/ethereum/erc721/transfer"\n    "github.com/anconprotocol/node/x/anconsync/handler/graphql"\n    "github.com/ethereum/go-ethereum/common/hexutil"\n)\n\ntype DurinAPI struct {\n    Namespace string\n    Version   string\n    Service   *DurinService\n    Public    bool\n}\n\ntype DurinService struct {\n    Adapter   *transfer.OnchainAdapter\n    GqlClient *graphql.Client\n}\n\nfunc NewDurinAPI(evm transfer.OnchainAdapter, gqlClient *graphql.Client) *DurinAPI {\n    return &DurinAPI{\n        Namespace: "durin",\n        Version:   "1.0",\n        Service: &DurinService{\n            Adapter:   &evm,\n            GqlClient: gqlClient,\n        },\n        Public: true,\n    }\n}\n\nfunc msgHandler(ctx *DurinService, to string, name string, args map[string]string) (hexutil.Bytes, string, error) {\n    switch name {\n    default:\n        tokenId := args["tokenId"]\n        input := graphql.MetadataTransactionInput{\n            Path:     "/",\n            Cid:      args["metadataCid"],\n            Owner:    args["fromOwner"],\n            NewOwner: args["toOwner"],\n        }\n        // Send graphql mutation for IPLD DAG computing\n        res, err := ctx.GqlClient.TransferOwnership(context.Background(), input)\n        if err != nil {\n            return nil, "", fmt.Errorf("transfer ownership reverted")\n        }\n        metadataCid := args["metadataCid"]\n        newCid := res.Metadata.Cid\n        newOwner := args["toOwner"]\n        fromOwner := args["fromOwner"]\n        prefix := args["prefix"]\n\n        // Apply signature to create proof\n        txdata, resultCid, err := ctx.Adapter.ApplyRequestWithProof(context.Background(),\n            metadataCid,\n            newCid,\n            fromOwner,\n            newOwner,\n            to,\n            tokenId,\n            prefix)\n        if err != nil {\n            return nil, "", fmt.Errorf("request with proof raw tx failed")\n        }\n        return txdata, resultCid, nil\n    }\n}\n\nfunc (s *DurinService) Call(to string, from string, data json.RawMessage, abis json.RawMessage) hexutil.Bytes {\n\n    p := []byte(data)\n    var values map[string]string\n    val := make(map[string]string, 2)\n    err := json.Unmarshal(p, &values)\n    if err != nil {\n        return hexutil.Bytes(hexutil.Encode([]byte(fmt.Errorf("fail unpack data").Error())))\n    }\n    // Execute graphql\n    txdata, resultCid, err := msgHandler(s, to, "", values)\n    if err != nil {\n        return hexutil.Bytes(hexutil.Encode([]byte(fmt.Errorf("reverted").Error())))\n    }\n\n    val["txdata"] = txdata.String()\n    val["resultCid"] = resultCid\n    jsonval, err := json.Marshal(val)\n    if err != nil {\n        return hexutil.Bytes(hexutil.Encode([]byte(fmt.Errorf("reverted, json marshal").Error())))\n    }\n    return jsonval\n}\n\n')))}l.isMDXComponent=!0}}]);