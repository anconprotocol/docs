"use strict";(self.webpackChunkancon_docs=self.webpackChunkancon_docs||[]).push([[690],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return g}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var a=r.createContext({}),p=function(e){var n=r.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=p(e.components);return r.createElement(a.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(t),g=o,h=u["".concat(a,".").concat(g)]||u[g]||d[g]||i;return t?r.createElement(h,s(s({ref:n},l),{},{components:t})):r.createElement(h,s({ref:n},l))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,s=new Array(i);s[0]=u;var c={};for(var a in n)hasOwnProperty.call(n,a)&&(c[a]=n[a]);c.originalType=e,c.mdxType="string"==typeof e?e:o,s[1]=c;for(var p=2;p<i;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7943:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return a},metadata:function(){return p},toc:function(){return l},default:function(){return u}});var r=t(7462),o=t(3366),i=(t(7294),t(3905)),s=["components"],c={sidebar_position:5},a="Subgraph networks",p={unversionedId:"api/graphsync",id:"api/graphsync",isDocsHomePage:!1,title:"Subgraph networks",description:"Ancon Protocol node can also be used for DAG block exchange using GraphQL. The process starts with an indexer, a chain listener",source:"@site/docs/api/graphsync.md",sourceDirName:"api",slug:"/api/graphsync",permalink:"/docs/api/graphsync",editUrl:"https://github.com/anconprotocol/ancon-docs/docs/api/graphsync.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"IPLD Operations",permalink:"/docs/api/ipld"},next:{title:"Data Unions",permalink:"/docs/tutorials/data-unions"}},l=[{value:"Indexing",id:"indexing",children:[],level:2},{value:"CosmosIndexer",id:"cosmosindexer",children:[],level:2},{value:"Advanced usage - Creating extension and hooks",id:"advanced-usage---creating-extension-and-hooks",children:[],level:2}],d={toc:l};function u(e){var n=e.components,t=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"subgraph-networks"},"Subgraph networks"),(0,i.kt)("p",null,"Ancon Protocol node can also be used for DAG block exchange using GraphQL. The process starts with an indexer, a chain listener\nwhich converts blocks in JSON to specific DAG format. Defaults to dagjson otherwise implement a custom DAG format."),(0,i.kt)("p",null,"A subgraph network is where one or more nodes are in a Graphsync protocol network exchanging blocks. These blocks can have typed messages packets called extensions. With an actor like developer API, these extensions can be implemented with checks or assertions using hooks."),(0,i.kt)("p",null,"An interesting example might be a data union where many Ancon Protocol nodes are specific to a certain extension data and with hooks checks can authenticate, authorize, compute or some other logic related to the extension data block."),(0,i.kt)("h2",{id:"indexing"},"Indexing"),(0,i.kt)("p",null,"Ancon Protocol comes with two blockchain indexer, a CosmosIndexer and Ethereum/EVM Indexer. "),(0,i.kt)("h2",{id:"cosmosindexer"},"CosmosIndexer"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Configure environment variables for the indexer, eg ",(0,i.kt)("inlineCode",{parentName:"li"},"COSMOS_PRIMARY_ADDRESS=tcp://\nlocalhost:26657")),(0,i.kt)("li",{parentName:"ul"},"The indexer will start indexing depending on query type, you can pick any of the existing category or create an ad-hoc query."),(0,i.kt)("li",{parentName:"ul"},"To get the last link or tip, make a request to ",(0,i.kt)("inlineCode",{parentName:"li"},"GET /indexer/cosmos/tip")),(0,i.kt)("li",{parentName:"ul"},"From that tip, query with GraphQL ")),(0,i.kt)("h2",{id:"advanced-usage---creating-extension-and-hooks"},"Advanced usage - Creating extension and hooks"),(0,i.kt)("p",null,"To implement your own subgraph networks, you can create a new router and network, based off ",(0,i.kt)("inlineCode",{parentName:"p"},"x/anconsync/impl/router.go")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"x/anconsync/impl/network.go")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package impl\n\nimport (\n    "context"\n    "fmt"\n\n    "github.com/anconprotocol/node/x/anconsync"\n    gsync "github.com/ipfs/go-graphsync"\n    graphsync "github.com/ipfs/go-graphsync/impl"\n    gsnet "github.com/ipfs/go-graphsync/network"\n    "github.com/multiformats/go-multiaddr"\n\n    "github.com/ipld/go-ipld-prime/node/basicnode"\n    "github.com/libp2p/go-libp2p-core/host"\n    peer "github.com/libp2p/go-libp2p-core/peer"\n    dht "github.com/libp2p/go-libp2p-kad-dht"\n)\n\nfunc NewRouter(ctx context.Context, gsynchost host.Host, s anconsync.Storage, peerhost string) (gsync.GraphExchange, *peer.AddrInfo) {\n\n    var pi *peer.AddrInfo\n    for _, addr := range dht.DefaultBootstrapPeers {\n        pi, _ = peer.AddrInfoFromP2pAddr(addr)\n        gsynchost.Connect(ctx, *pi)\n    }\n\n    network := gsnet.NewFromLibp2pHost(gsynchost)\n\n    // Add Ancon fsstore\n    exchange := graphsync.New(ctx, network, s.LinkSystem)\n\n    // var receivedResponseData []byte\n    // var receivedRequestData []byte\n\n    exchange.RegisterIncomingResponseHook(\n        func(p peer.ID, responseData gsync.ResponseData, hookActions gsync.IncomingResponseHookActions) {\n            fmt.Println(responseData.Status().String(), responseData.RequestID())\n        })\n\n    exchange.RegisterIncomingRequestHook(func(p peer.ID, requestData gsync.RequestData, hookActions gsync.IncomingRequestHookActions) {\n        // var has bool\n        // receivedRequestData, has = requestData.Extension(td.extensionName)\n        // if !has {\n        //  hookActions.TerminateWithError(errors.New("Missing extension"))\n        // } else {\n        //  hookActions.SendExtensionData(td.extensionResponse)\n        // }\n        hookActions.ValidateRequest()\n        hookActions.UseLinkTargetNodePrototypeChooser(basicnode.Chooser)\n        fmt.Println(requestData.Root(), requestData.ID(), requestData.IsCancel())\n    })\n    finalResponseStatusChan := make(chan gsync.ResponseStatusCode, 1)\n    exchange.RegisterCompletedResponseListener(func(p peer.ID, request gsync.RequestData, status gsync.ResponseStatusCode) {\n        select {\n        case finalResponseStatusChan <- status:\n        default:\n        }\n    })\n    pi, _ = peer.AddrInfoFromP2pAddr(multiaddr.StringCast(peerhost))\n    // err := network.ConnectTo(ctx, pi.ID)\n    // if err != nil {\n    //  panic(err)\n    // }\n\n    a := fmt.Sprintf("%s/p2p/%s", gsynchost.Addrs()[0].String(), gsynchost.ID().Pretty())\n\n     return exchange, pi\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package impl\n\nimport (\n    "context"\n    "fmt"\n\n    "time"\n\n    blocks "github.com/ipfs/go-block-format"\n\n    "github.com/ipfs/go-cid"\n    "github.com/ipfs/go-graphsync"\n    gsync "github.com/ipfs/go-graphsync"\n    gsmsg "github.com/ipfs/go-graphsync/message"\n    blockstore "github.com/ipld/go-car/v2/blockstore"\n    "github.com/ipld/go-ipld-prime"\n    "github.com/ipld/go-ipld-prime/datamodel"\n    "github.com/ipld/go-ipld-prime/node/basicnode"\n    ipldselector "github.com/ipld/go-ipld-prime/traversal/selector"\n    "github.com/ipld/go-ipld-prime/traversal/selector/builder"\n\n    "github.com/libp2p/go-libp2p"\n    connmgr "github.com/libp2p/go-libp2p-connmgr"\n    crypto "github.com/libp2p/go-libp2p-core/crypto"\n    "github.com/libp2p/go-libp2p-core/host"\n    peer "github.com/libp2p/go-libp2p-core/peer"\n    "github.com/libp2p/go-libp2p-core/routing"\n    kaddht "github.com/libp2p/go-libp2p-kad-dht"\n    noise "github.com/libp2p/go-libp2p-noise"\n)\n\nfunc NewPeer(ctx context.Context, addr string) host.Host {\n    // Set your own keypair\n    priv, _, err := crypto.GenerateKeyPair(\n        crypto.Ed25519, // Select your key type. Ed25519 are nice short\n        -1,             // Select key length when possible (i.e. RSA).\n    )\n    if err != nil {\n        panic(err)\n    }\n\n    var dht *kaddht.IpfsDHT\n    newDHT := func(h host.Host) (routing.PeerRouting, error) {\n        var err error\n        dht, err = kaddht.New(ctx, h)\n        return dht, err\n    }\n\n    gsynchost, err := libp2p.New(\n        ctx,\n        // Use the keypair we generated\n        libp2p.Identity(priv),\n        libp2p.Security(noise.ID, noise.New),\n        // Multiple listen addresses\n        libp2p.ListenAddrStrings(addr),\n        libp2p.ConnectionManager(connmgr.NewConnManager(\n            100,         // Lowwater\n            400,         // HighWater,\n            time.Minute, // GracePeriod\n        )),\n        libp2p.NATPortMap(),\n        libp2p.Routing(newDHT),\n        libp2p.EnableAutoRelay(),\n        libp2p.EnableNATService(),\n    )\n    if err != nil {\n        panic(err)\n    }\n    return gsynchost\n}\ntype ReceivedMessage struct {\n    Message gsmsg.GraphSyncMessage\n    Sender  peer.ID\n}\n\n// Receiver is an interface for receiving messages from the GraphSyncNetwork.\ntype Receiver struct {\n    MessageReceived chan ReceivedMessage\n}\n\nfunc (r *Receiver) ReceiveMessage(\n    ctx context.Context,\n    sender peer.ID,\n    incoming gsmsg.GraphSyncMessage) {\n\n    select {\n    case <-ctx.Done():\n    case r.MessageReceived <- ReceivedMessage{incoming, sender}:\n    }\n}\n\nfunc (r *Receiver) ReceiveError(_ peer.ID, err error) {\n    fmt.Println("got receive err")\n}\n\nfunc (r *Receiver) Connected(p peer.ID) {\n}\n\nfunc (r *Receiver) Disconnected(p peer.ID) {\n}\n\nfunc VerifyHasErrors(ctx context.Context, errChan <-chan error) error {\n\n    for {\n        select {\n        case e, ok := <-errChan:\n            if ok {\n                return nil\n            } else {\n                return e\n            }\n        case <-ctx.Done():\n        }\n    }\n}\n\nfunc PrintProgress(ctx context.Context, pgChan <-chan gsync.ResponseProgress) {\n    errCount := 0\n    for {\n        select {\n        case _, ok := <-pgChan:\n            if ok {\n                fmt.Println("ok")\n            }\n            errCount++\n        case <-ctx.Done():\n        }\n    }\n\n}\n\nvar selectAll ipld.Node = func() ipld.Node {\n    ssb := builder.NewSelectorSpecBuilder(basicnode.Prototype.Any)\n    return ssb.ExploreRecursive(\n        ipldselector.RecursionLimitDepth(100), // default max\n        ssb.ExploreAll(ssb.ExploreRecursiveEdge()),\n    ).Node()\n}()\n\nfunc FetchBlock(ctx context.Context, exchange graphsync.GraphExchange, ipfspeer *peer.AddrInfo, c ipld.Link) error {\n    ctx, cancel := context.WithCancel(ctx)\n    defer cancel()\n\n    resps, errs := exchange.Request(ctx, ipfspeer.ID, c, selectAll)\n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        case _, ok := <-resps:\n            if !ok {\n                resps = nil\n            }\n        case err, ok := <-errs:\n            if !ok {\n                // done.\n                return nil\n            }\n            if err != nil {\n                return fmt.Errorf("got an unexpected error: %s", err)\n            }\n        }\n    }\n}\nfunc PushBlock(ctx context.Context, exchange graphsync.GraphExchange, ipfspeer *peer.AddrInfo, c ipld.Link) error {\n    ctx, cancel := context.WithCancel(ctx)\n    defer cancel()\n\n    resps, errs := exchange.Request(ctx, ipfspeer.ID, c, selectAll, gsync.ExtensionData{\n        Name: graphsync.ExtensionMetadata,\n        Data: []byte{},\n    })\n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        case _, ok := <-resps:\n            if !ok {\n                resps = nil\n            }\n        case err, ok := <-errs:\n            if !ok {\n                // done.\n                return nil\n            }\n            if err != nil {\n                return fmt.Errorf("got an unexpected error: %s", err)\n            }\n        }\n    }\n}\n')))}u.isMDXComponent=!0}}]);